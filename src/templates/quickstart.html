{% extends "base.html" %}
{% block title %} Quick Start | Simple ETL Scripting for Postgres, MySql, and Oracle {% endblock %}
{% block content %}
<div class="page-header">
<h1>Quick Start</h1>
</div>
<div class="page-header">
<h2>Getting Set up</h2>
</div>
<h3>Step 1: Install Java</h3>
<p>You are likely to have the Java runtime on your machine already, but if you need to install
    it, you can download it (version 1.6 or greater) 
    <a href="http://www.oracle.com/technetwork/java/javase/downloads/jre-7u3-download-1501631.html">directly from Oracle</a>.</p>
    <p><span class="label label-info">Mac OS X Note</span></p>
    <p>If you are running Mac OS X, the Java runtime is shipped by Apple. You can ensure it is installed by running Software Update.</p>
<h3>Step 2: Download and Install Scala</h3>
<p>Downloads for Scala are available for multiple platforms from the <a href="http://www.scala-lang.org/downloads">Scala website</a>. The
    download does not include an installer. You can place the files anywhere, you just need to ensure the <code>scala/bin</code> directory 
    is on your path for your operating system. You can see further instructions for doing this in the <code>doc/README</code> file in the 
    Scala distribution you downloaded.</p>
<p>Test your setup by typing <code>scala</code> from the command prompt. You should see something like the following: 
<pre class="prettyprint">new-host-4:~ username$ scala
Welcome to Scala version 2.10.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.7.0_11).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt;</pre>
    
    <p>If you get an error saying scala isn't found, you may not have added it to your
    path properly. Be sure to check the <code>doc/README</code> file.</p>
    <p>To quit, just type <code>:quit</code> at the prompt.</p>
<h3>Step 3: Download DataExpress </h3>

<p>Visit the <a href="https://github.com/cbmi/dataexpress/releases">Releases page</a> on GitHub the current version of DataExpress. You'll want to grab both the "standalone" version as well as the zip file that contains the required files for this tutorial.
</p>

 <p>At this point, you have most of what you need to begin using DataExpress.</p>
<h3>Step 4: Download JDBC Drivers for your Databases <span class="label">Optional</span></h3>
To keep things simple for demonstration purposes, we are going to be using two <a href="http://sqlite.org/">SQLite</a> databases. SQLite support
is bundled into DataExpress. If that's fine with you, feel free to skip the rest of this step.</p>
<p>Part of the fun of DataExpress is (hopefully) effortless movement of data between database platforms. If you would like to swap 
out the target SQLite database for an Oracle, MySQL, Postgres, or SQL Server database feel free to do so. We just didn't want to put too
many barriers up for getting people acquainted with the tool. If you use a commercial database, you'll need to supply your own driver. 
Below is a comprehensive list of databases and drivers supported by DataExpress:</p>
<table class="table">
  <thead>
    <tr>
      <th>Database Platform</th>
      <th>Version Tested</th>
      <th>Download URL</th>
    </tr>
  </thead>
  <tbody>

    <tr>
        <td>Microsoft SQL Server</td>
        <td>MS SQL Server 2008 R2</td>
        <td><a href="http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=11774">Download</a></td>
    </tr>
    <tr>
        <td>MySQL</td>
        <td>5.1.19</td>
        <td><span class="label label-success">Included  </span></td>
    </tr>
    <tr>
        <td>Oracle</td>
        <td>11g (11.2.0.3)</td>
        <td><a href="http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-112010-090769.html">Download</a></td>
    </tr>
    <tr>
        <td>PostgreSQL</td>
        <td>9.1</td>
        <td><span class="label label-success">Included</span></td>
    </tr>
    <tr>
        <td>SQLite</td>
        <td>3</td>
        <td><span class="label label-success">Included</span></td>
    </tr>   
        
  </tbody>
</table>

<div class="alert alert-info">
<p>While we would love to distribute DataExpress as a self-contained application, the various licenses associated with commercial 
    database drivers make this difficult to do easily. The source code
    distribution for DataExpress includes a build script that allows you to bundle all dependencies into a single .jar file for convenience.
    While we can't distribute this .jar ourselves, it's fairly painless to create on your own see the section 
    <a href="#build-from-source">Building From Source</a> below.
</p>
</div>

<h3>Step 5: Prepare a working directory</h3>
<p>For the purposes of the tutorial, we are going to create a directory to hold the various files that we'll need:
    <ol>
        <li>If you haven't already done so, download the zip file starting with the name "tutorial_files" from our <a href="https://github.com/cbmi/dataexpress/releases">GitHub releases page</a></li>
        <li>Unzip the file in the directory of your choice. It will create a <code>de_tutorial</code> directory with everything you need.</li>        
        <li>Copy the DataExpress standalone <code>.jar</code> file you downloaded above to <code>de_tutorial/lib</code>.</li>         
        <li>Let's test the installation and get some starter data loaded into our source database. 
    </ol>
        
     <div class="alert alert-info">
         <p><strong>Using a Different Relational Database</strong></p>
         <p>DataExpress uses Java properties files to store database credentials. This allows you to write your scripts without hard-coding usernames, passwords,
            and server names into the script.</p>
       
       <!-- TODO remove this once the downlaod page is setup -->
       <p>If you would like to use something other than SQLite for the tutorial, you will need to create an appropriate properties file and 
       save it in the <code>de_tutorial/conf</code> directory. The content found <b><a href=https://github.com/downloads/cbmi/dataexpress/mysql.properties>here</a></b> is appropriate for a MySQL server
       running on the localhost on port 3306 with a database named de_tutorial. The content found <b><a href=https://github.com/downloads/cbmi/dataexpress/postgres.properties>here</a></b> is appropriate 
       for a PostgreSQL server running on the localhost on port 5432 with a database named de_tutorial. The use of these files is described further in the following sections.
       <i>de_tutorial</i>.
        <p><span class="label label-info">Important</span></p>
        <p>If you're going to use one of the 
        supported commercial databases, make sure to deposit the JDBC driver <code>.jar</code> files in the <code>de_tutorial/lib</code></p>
    </div>

</pre>
<div class="page-header">
<h2>Loading Test Data</h2>
</div>
<p>In this demo we will have two databases: <code>source</code> and <code>target</code>. We will test our setup by executing a Scala script that uses DataExpress to load
     some demo data into a few tables in our <code>source</code> database.</p> from the root <code>de_tutorial</code> directory, run the following command from 
     the command prompt (see note below if your are using something other than SQLite):</p>
     
<span class="label label-inverse">Windows</span>
<pre>
scala -cp "lib\*;" source_database_setup.scala
</pre>

<span class="label label-inverse">Linux/OS X</span>
<pre>
scala -cp "lib/*" source_database_setup.scala
</pre>
<p>The <code>-cp</code> command line switch tells Scala to look in the <code>lib</code> directory for any dependencies that it can't find on the Java classpath.
    You can remove this restriction if you set a classpath environment variable and deposit DataExpress and any other libraries you might need to a location listed there.</p>
<p>If you saw the following output, then the database tables were set up correctly:</p>
<pre>Creating table 'presidents'...
Inserting rows into presidents
You're using SQLite, so we need to clean up the dates a little
Success!</pre>

<div class="alert alert-info">
<p><strong>Using a Different Relational Database</strong></p>
If you are using a Relational Database other than SQLite for this tutorial then executing the <code>source_database_setup.scala</code> command must be 
modified to include arguments for the source and target Java properties files as shown here:
<br/>
<span class="label label-inverse">Windows</span>
<pre>
scala -cp "lib\*;" source_database_setup.scala "X.properties" "Y.properties"
</pre>
<span class="label label-inverse">Linux/OS X</span>
<pre>
scala -cp "lib/*" source_database_setup.scala "X.properties" "Y.properties"
</pre>
where X and Y are the name of the source and target properties files respectively. The <code>source_database_setup.scala</code> script requires that these
file be placed in the <code>de_tutorial/conf</code> directory. If you are using the same database for both the source and target, simply specify the same connection properties 
file name for both X and Y.
</div>

<div class="page-header">
<h2>Copying a Table</h2>
</div>
<p>We're going to use the Scala interpreter for our examples. The interpreter lets you interactively type Scala code and see the output immediately. To launch
    the interpreter do the following:</p>
<span class="label label-inverse">Windows</span>
<pre>
scala -cp "lib\*;"
</pre>

<span class="label label-inverse">Linux/OS X</span>
<pre>
scala -cp "lib/*"
</pre>
<p>You'll see the same screen you saw above when we tested the installation.</p>
<p>Let's get started!</p>
<p>First we need to import some of the libraries we need. Execute each import statement below:
<pre>
import edu.chop.cbmi.dataExpress.dsl.ETL._
import edu.chop.cbmi.dataExpress.dsl.ETL
import edu.chop.cbmi.dataExpress.dsl.stores.SqlDb
import edu.chop.cbmi.dataExpress.dataModels.RichOption._
</pre>

<p>Most actions in DataExpress are designed to work with one or more databases acting as a source and another
    database acting as a target. You connect to the database by registering a new <code>DataStore</code>:
<pre>
register store SqlDb("conf/source.properties") as "source"
register store SqlDb("conf/target.properties") as "target"
</pre>
<p>Above we set up a table called "presidents" in the source database. We are going to copy
that table from the source into a brand new table called presidents_copy in our target database 
using the following code:</p>
<pre>
commit_on_success("target"){ 
      copy table "presidents" from "source" to "target" create "presidents_copy"
}
</pre>



<p>If you've done everything right, your whole session will look something like this:</p>
<pre>
Welcome to Scala version 2.10.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_31).
Type in expressions to have them evaluated.
Type :help for more information.

scala> import edu.chop.cbmi.dataExpress.dsl.ETL._
import edu.chop.cbmi.dataExpress.dsl.ETL._

scala> import edu.chop.cbmi.dataExpress.dsl.{ETL}
import edu.chop.cbmi.dataExpress.dsl.ETL

scala> import edu.chop.cbmi.dataExpress.dsl.stores.{SqlDb}
import edu.chop.cbmi.dataExpress.dsl.stores.SqlDb

scala> register store SqlDb("conf/source.properties") as "source"
res1: edu.chop.cbmi.dataExpress.dsl.stores.Store = edu.chop.cbmi.dataExpress.dsl.stores.SqlDb@1cf536e8

scala> register store SqlDb("conf/target.properties") as "target"
res2: edu.chop.cbmi.dataExpress.dsl.stores.Store = edu.chop.cbmi.dataExpress.dsl.stores.SqlDb@8bfc25c

scala> commit_on_success("target"){ 
     |     copy table "presidents" from "source" to "target" create "presidents_copy"
     | }
res3: Boolean = true

scala>
</pre>
<p>That's it! That is all you need to do to copy tables from one database to another. DataExpress tries
as best as possible to map data types between platforms (though sometimes, it's not that easy).
That said, this is all a bit anticlimactic since we can't actually <em>see</em> anything. We have been using the DataExpress
DSL for these operations which is deliberately designed to be easy to work with, but the tradeoff is that it isn't
yet as fully functional as the full DataExpress API. We will now use the API to take a look at some of the data.</p>
<p>First, we need to close the connection to the databases. Type the following to do so:</p>
<pre>
"source" close
"target" close
</pre>
<p>Next, we are going to import some of the things we need for the API:</p>

<div class="page-header">
<h2>Getting Data From A Table</h2>
</div>
<p>Now that we've seen how to copy a table, let's see how to get a table and view some of it's content. Continuing with our
previous session in the Scala interpreter, execute the following statements</p>
<pre>
val the_presidents = get table "presidents" from "source"
the_presidents foreach {row => println(row.name.asu[String])}
val washington = the_presidents.head
println(washington.name.asu[String])
</pre>

<p>If you're familiar with Scala, you'll recoginize the use of the <code>foreach</code> and <code>head</code> methods used in this 
example. The object returned by the <code>get table ...</code> DSL statemnt is of type <code>DataTable</code> which has all the normal methods found in 
a Scala collection. Each element in the a <code>DataTable</code> is a <code>DataRow</code> which extends a Scala <code>Seq</code>. In addition to 
all the methods provided by extending <code>Seq</code>, <code>DataRow</code> also enables you to access row elements by column name using the dot notation as 
in the example, <code>row.x</code> where <b>x</b> is any column name in the extracted table.</p>

<p>If you've done everything correctly you should see output like the following</p>
<pre>
scala> val the_presidents = get table "presidents" from "source"
the_presidents: edu.chop.cbmi.dataExpress.dataModels.DataTable[Any] = DataTable[id, name, party, dob, dod, term_start, term_end]

scala> the_presidents foreach {row => println(row.name.asu[String])}
dynatype: row.applyDynamic("name")()
Abraham Lincoln
Andrew Jackson
Andrew Johnson
Bill Clinton
...

scala> val washington = the_presidents.head
washington: edu.chop.cbmi.dataExpress.dataModels.DataRow[Any] = DataRow(Some(16), Some(Abraham Lincoln), Some(Republican Party), Some(-5077018800000), Some(-3304436400000), Some(-3434295600000), Some(-3304436400000))

scala> println(washington.name.asu[String])
dynatype: $line9.$read.$iw.$iw.$iw.$iw.$iw.$iw.washington.applyDynamic("name")()
Abraham Lincoln
</pre>

<div class="page-header">
<h2>Copying a SQL statement</h2>
</div>
<div class="alert alert-info">
<p>Please forgive our tardiness! We are still working on this section</p>
</div>

<div class="page-header">
<h2>Copy with transform</h2>
</div>
<div class="alert alert-info">
<p>Please forgive our tardiness! We are still working on this section</p>
</div>

<div class="page-header">
<h2>Copy between different database implementations</h2>
</div>
<div class="alert alert-info">
<p>Please forgive our tardiness! We are still working on this section</p>
</div>
<h1>Advanced Examples</h1>
<div class="page-header">
<h2>Copy with temporary staging table</h2>
</div>
<p>Here we will copy a table between two databases, using the destination database to stage our final table. We will also look at how to apply conditional logic depending
on the type of database backend.<p>
<p> For context, let's create a contrived president tracking scenario. We have two databases, the source database from the above examples (we will pretend this is an upstream system) and a target (again, the same as above), which is our local system. Each has a table that tracks presidents. Our local database table
has only has a subset of the columns from the source database: id, name, party, birthday (instead of dob), and one additional column, created, which is a timestamp for when the record was created. Let's go ahead and create this table and add our first president.
<pre>
val target2Store = SqlDb("conf/target.properties")

target2Store.backend.connect()
target2Store.backend.execute("CREATE TABLE presidents_timestamp (id INTEGER, name VARCHAR(100), party VARCHAR(100), birthday DATE, created DATE);")
target2Store.backend.execute("INSERT INTO presidents_timestamp VALUES (1, 'George Washington', 'Independent', date('1732-02-22'), date('now'))")
target2Store.backend.commit()
</pre>
<p> We now have a new table with one president in it. In the contrived workflow, our downstream presidents database is updated with new presidents as they are elected, and we need to update our local database. We want an ETL script that copies the presidents from the downstream table and adds them to our local table if they 
do not yet exist.  Our approach will be to copy a subset of the source database to our local database into a staging table. We will then copy from the staging table in our local database to the real table in our local database, only adding presidents we do not already have. Also note, that while not necessary in 
this example (since we know we are using sqlite), the code examines the SqlDB object we created to find out what type the backend is. It then uses this information to determine the command to use to get the current time in that type of database.
</p>
<pre>
import edu.chop.cbmi.dataExpress.backends._

// We previously created target2Store, but now we register it for use within the DSL
register store target2Store as "target2"

// This should work for postgres, mysql and sqlite but is not exhaustive
val time = target2Store match {
  case s:SqlDb => s.backend match {
    case sl:SqLiteBackend => "date('now')"
    case _ =>"now()"
  }
  case _ => "now()"
}

val staging_query = """select id, name, party, dob as birthday from presidents"""

val timestamp_query = s"""select id, name, party, birthday,
                      $time as created from staging_presidents
                      where name not in (select name from presidents_timestamp)"""

commit_on_success("target") {
  copy query staging_query from "source" to "target" create "staging_presidents"
}

// Note that target1 and target2 are the same database, 
// but we need two connections because we are copying and saving
// to the same database and that cannot be done over the same connection
commit_on_success("target2") {
  copy query timestamp_query from "target" to "target2" append "presidents_timestamp"
}

// Note if we want to delete the staging table, we can do so.
// It is left in for the demo for you to examine
//target2Store.backend.connect()
//target2Store.backend.execute("drop table presidents_staging")
//target2Store.backend.commit()
</pre>

<div class="page-header">
    <h2>XML file to database by subclassing DataTable</h2>
</div>
<p> It may be useful in some situations to subclass DataTable. For example, one way to create a table without first creating an in-memory list would be 
to subclass DataTable and override the iterator methods so that it creates each row on demand. Let's take a look at an example that shows how to do this</p>
<p> We will start with an XML file containing the same presidents information as the source database created by the setup script. This can be found in the presidents.xml file in the de_tutorial package. We will than recreate the source sqlite
database from the XML file.  

<p> First set up some variables we will need: <code>col_names</code> is a list of the column names for our table, <code>c</code> is a variable that is currently necessary for subclassing DataTable, and <code>df</code> is used to parse the date strings in the XML file. </p>
<pre>
val col_names = List("id", "name", "party", "dob", "dod", "term_start", "term_end")

object c extends ColumnNameGenerator {
   def generate_column_names = col_names
}
val df = new java.text.SimpleDateFormat("yyyy-MM-dd")
</pre>
<p> We then subclass DataTable. The most important method here is <code>next</code> which we use to create DataRows on the fly from our XML file.</p>

<pre>
class PresidentsTable extends DataTable[Any](c) {

    val data = XML.loadFile("src/main/resources/presidents.xml")
    val presidents = data \\ "president"

    val dataIterator = presidents.toIterator

    lazy val dataTypes = {
      Seq[DataType]()
    }

    override def col(name: String) : Iterator[Option[String]]  = ???

    override def col_as[G](name: String)(implicit m: Manifest[G]) : Iterator[Option[G]] = ???

    override def col_asu[G](name: String)(implicit m: Manifest[G]) : Iterator[G] = ???

    override def hasNext = dataIterator.hasNext

    override def next:DataRow[Any] = {
      val n = dataIterator.next
      DataRow(col_names)(List(n \ "id" text,
        n \ "name" text,
        n \ "party" text, df.parse(n \ "dob" text),
        if ((n \ "dod" text).length > 0) df.parse(n \ "dod" text) else null,
        if ((n \ "term_start" text).length > 0) df.parse(n \ "term_start" text) else null,
        if ((n \ "term_end" text).length > 0) df.parse(n \ "term_end" text) else null) map (Some(_)))
    }
}
</pre>
<p>Finally, we create an instance of our DataTable and a connection to a sqlite database, where we then save the table.</p>
<pre>
val table =  new PresidentsTable()

// We can create a Properties object dynamically instead of reading from a file.
val props = new Properties()
props.put("jdbcUri", "jdbc:sqlite:target/presidents.sqlite")

val db = new SqLiteBackend(props)

db.connect()
db.createTable("presidents", col_names, dataTypes = List(IntegerDataType,
  CharacterDataType(100, false),
  CharacterDataType(100, false),
  DateDataType,
  DateDataType,
  DateDataType,
  DateDataType))

db.batchInsert("presidents", table)
db.commit()
db.close()
</pre>
<p>At this point, there is a new database called presidents.sqlite that contains a presidents table that is identical to the one in source.sqlite.</p>

<div class="page-header">
<h2>Working with DataExpress Scripts</h2>
</div>
<div class="alert alert-info">
<p>Please forgive our tardiness! We are still working on this section</p>
</div>

<!--
<h2>Learning More</h2>
Refer people to chapter 1 of "programming scala" ebook on the o'reilly website: http://ofps.oreilly.com/titles/9780596155957/IntroducingScala.html
-->
</div>
{% endblock %}
